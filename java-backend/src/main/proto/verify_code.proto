syntax = "proto3";

option java_multiple_files = true;
option java_package = "com.xinyu.grpc";
option java_outer_classname = "VerifyCodeProto";

package verify.v1;

import "google/protobuf/timestamp.proto";
import "google/protobuf/duration.proto";

/// 验证码通道/接收类型
enum Channel {
  CHANNEL_UNSPECIFIED = 0;
  SMS = 1;     // 手机短信
  EMAIL = 2;   // 邮件
}

/// 验证码业务场景（强烈建议按业务细分）
enum Scene {
  SCENE_UNSPECIFIED = 0;
  REGISTER = 1;        // 注册
  LOGIN = 2;           // 登录
  RESET_PASSWORD = 3;  // 重置密码
  BIND = 4;            // 绑定手机号/邮箱
  CHANGE = 5;          // 变更手机号/邮箱
}

/// 风控动作：用于告诉调用方“该怎么做”
enum RiskAction {
  RISK_ACTION_UNSPECIFIED = 0;
  ALLOW = 1;        // 允许发送/允许校验
  REQUIRE_CAPTCHA = 2; // 需要验证码/图形验证码/人机校验（由你们业务实现）
  BLOCK = 3;        // 拒绝（高风险/黑名单）
}

/// 统一错误码（业务码）
/// 建议：code=0 表示成功；非 0 表示失败；message 给用户可读信息（谨慎暴露细节）
enum ErrorCode {
  ERROR_CODE_UNSPECIFIED = 0;
  OK = 1;

  INVALID_ARGUMENT = 1001;   // 参数非法
  TOO_MANY_REQUESTS = 1002;  // 触发限流/冷却
  RISK_BLOCKED = 1003;       // 风控拦截
  NOT_FOUND = 1004;          // verification_id 不存在/无效
  EXPIRED = 1005;            // 过期
  CODE_MISMATCH = 1006;      // 验证码错误
  TOO_MANY_ATTEMPTS = 1007;  // 校验失败次数过多
  INTERNAL_ERROR = 2000;     // 服务器内部错误
}

/// 客户端信息：用于风控、审计、限流（不要完全信任，建议结合网关/服务端注入）
message ClientInfo {
  string request_id = 1;   // 幂等键：同一个 request_id 在冷却期内可返回同一结果（可选）
  string ip = 2;           // 客户端 IP（建议由网关填充）
  string user_agent = 3;   // UA（可选）
  string device_id = 4;    // 设备标识（可选）
  string app_id = 5;       // 调用方应用标识（多应用/多租户时有用）
  string tenant_id = 6;    // 租户/组织（可选）
}

/// 发送验证码请求
message SendVerifyCodeRequest {
  Channel channel = 1;     // SMS/EMAIL
  Scene scene = 2;         // REGISTER/LOGIN/...
  string receiver = 3;     // 手机号(建议 E.164) 或 邮箱（由 channel 决定）
  int32 code_length = 4;   // 例如 6（服务端可忽略并强制固定，避免被滥用）
  ClientInfo client = 5;   // 用于风控、审计、限流
}

/// 发送验证码响应（生产环境不返回 verify_code）
message SendVerifyCodeReply {
  ErrorCode code = 1;
  string message = 2;

  string verification_id = 3;                 // 校验用的短期凭证（重要）
  google.protobuf.Timestamp sent_at = 4;      // 发送时间
  google.protobuf.Duration ttl = 5;           // 验证码有效期
  google.protobuf.Duration cooldown = 6;      // 冷却时间（还需等多久才能再次发送）

  RiskAction risk_action = 7;                 // ALLOW / REQUIRE_CAPTCHA / BLOCK
  bool exists = 8;                            // 可选：是否该 receiver 已存在（⚠️注意枚举/用户枚举风险，默认不建议开启）
}

/// 校验验证码请求
message VerifyCodeRequest {
  string verification_id = 1; // 来自 SendVerifyCodeReply
  string code = 2;            // 用户输入的验证码
  ClientInfo client = 3;      // 用于风控与审计（建议由网关补全）
}

/// 校验验证码响应
message VerifyCodeReply {
  ErrorCode code = 1;
  string message = 2;

  bool verified = 3;                         // 是否通过（成功时 true）
  google.protobuf.Timestamp verified_at = 4; // 校验时间

  // 校验失败时可返回剩余尝试次数/锁定时间（避免暴露过多细节，可按需开启）
  int32 remaining_attempts = 5;
  google.protobuf.Duration lock_duration = 6; // 如果触发锁定，锁定多久

  RiskAction risk_action = 7;                // 校验阶段也可能触发风控
}

/// 可选：消费/确认使用验证码（防重放）
/// 如果你们希望“验证码校验通过后必须被消费一次”，可以加这个接口；否则 VerifyCode 成功即视为消费也行。
message ConsumeCodeRequest {
  string verification_id = 1;
  ClientInfo client = 2;
}

message ConsumeCodeReply {
  ErrorCode code = 1;
  string message = 2;
  bool consumed = 3;
  google.protobuf.Timestamp consumed_at = 4;
}

service VerifyCodeService {
  /// 发送验证码（生产级：不返回验证码内容）
  rpc SendVerifyCode(SendVerifyCodeRequest) returns (SendVerifyCodeReply);

  /// 校验验证码（建议：校验成功后立即失效或单次有效）
  rpc VerifyCode(VerifyCodeRequest) returns (VerifyCodeReply);

  /// 可选：消费验证码（如需要二次确认/防重放更严格）
  rpc ConsumeCode(ConsumeCodeRequest) returns (ConsumeCodeReply);
}
